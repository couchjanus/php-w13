<?php
// regexp.meta.test.php

$routes = [
  'contact' => 'ContactController@index',
  'about' => 'AboutController@index',
  'blog' => 'BlogController@index',
  'guest' => 'GuestbookController@index',

  'admin' => 'Admin\DashboardController@index',
  'admin/categories' => 'Admin\CategoryController@index',
  'admin/categories/create' => 'Admin\CategoryController@create',

  'admin/categories/create/1' => 'Admin\CategoryController@create',

  'admin/products' => 'Admin\ProductController@index',
  'admin/products/create' => 'Admin\ProductController@create',
  //Главаня страница
  'index.php' => 'HomeController@index',
  '' => 'HomeController@index',
];

// Метасимволы в регулярных выражениях

// Чаще всего мы заранее не знаем, какой текст нам придется парсить. Заранее известен только примерный набор правил. Будь то пинкод в смс, email в письме и т.п.

// Первый пример, нам надо получить все числа из текста:

$text = "Blaha muha 8282, 2828 muha Blaha";

// Чтобы выбрать любое число, надо собрать все числа, указав “[0123456789]”.

preg_match("/[0123456789]/", $text, $match);
var_dump(
    $match
);

// Более коротко можно задать вот так: “[0-9]”.

preg_match("/[0-9]/", $text, $match);
var_dump(
    $match
);

// Для всех цифр существует метасимвол “\d”.

// Но если мы укажем регулярное выражение “/\d/”, то нам вернётся только первая цифра.

preg_match("/\d/", $text, $match);
// preg_match_all("/\d/", $text, $match);
var_dump(
    $match
);

$uri = 'admin/categories/create/11';

foreach ($routes as $key => $val) {
    $pattern = '%'.$key.'/\d%';
    if (preg_match($pattern, $uri, $matches))
    var_dump(
        $matches
    );
}
//
$regexp = "/\d\d\d\d/";
$result = preg_match_all($regexp, $text, $match);

var_dump(
    $result,
    $match
);
//
//
$sresult = preg_match_all("/\D/", $text, $match);

var_dump(
    $sresult,
    $match
);
//
$sresult = preg_match_all("/\D\D\D\D/", $text, $match);

var_dump(
    $sresult,
    $match
);
//
//
$presult = preg_match_all("/\s/", $text, $match);

var_dump(
    $presult,
    $match
);
//
//
$eresult = preg_match_all("/\d\d\d[0,2,4,6,8]/", $text, $match);

var_dump(
    $eresult,
    $match
);

// Для того, чтобы вывести подстроку единым вхождением, существуют символы плюс “+” и звездочка “*”. Первый указывает, что нам подойдет подстрока, где есть как минимум один подходящий под набор символ. Второй — что данный набор символов может быть, а может и не быть.

// Текст: “Ваш пинкод: 24356” или “У вас нет пинкода.”
// Надо получить пинкод или ничего, если его нет.
// RegExp: “/\d*/”

// Помимо этого мы можем указать точное значение подходящих символов вот так: “{N}”, где N — нужное количество. Или задать “от” и “до”, указав вот так: “{N, M}”.

// Текст: “Номер телефона 89091534357”
// Надо получить первые 11 символов, или FALSE, если их меньше.
// RegExp: “/\d{11}/”

$eresult = preg_match_all("/[0,2,4,6,8]{4}/", $text, $match);

var_dump(
    $eresult,
    $match
);

// Примерно так же мы работает с буквами, не забывая, что у них бывает регистр. Вот так можно задавать буквы:

// [a-z]
// [a-zA-Z]
// [а-яА-Я]

// Выбираем все “не пробелы”.
$eresult = preg_match_all("/[a-z]{4}/", $text, $match);

var_dump(
    $eresult,
    $match
);

// C кириллицей указанный диапазон работает по-разному для разных кодировок. В юникоде, например, в этот диапазон не входит буква “ё”. Подробнее об этом тут.

//
// Текст: “Вот бежит олень” или “Вот ваш индюк”
// Надо выбрать либо слово “олень”, либо слово “индюк”.
// RegExp: “/[а-яА-Я]+/”
//
// Такое выражение выберет все слова, которые есть в предложении и написаны кириллицей. Нам нужно третье слово.

// Помимо букв и цифр у нас могут быть еще важные символы, такие как:
//
// \s — пробел
// ^ — начало строки
// $ — конец строки
// | — “или”
//
// Предыдущий пример стал проще:
//
// Текст: “Вот бежит олень” или “Вот бежит индюк”
// Надо выбрать либо “олень”, либо “индюк”.
// RegExp: “/[а-яА-Я]+$/”

// Если мы точно знаем, что искомое слово последнее, мы ставим “$” и результатом работы будет только тот набор символов, после которого идет конец строки.

// То же самое с началом строки:
//
// Текст: “Олень вкусный” или “Индюк вкусный”
// Надо выбрать либо “олень”, либо “индюк”.
// RegExp:  “/^[а-яА-Я]+/”

// В некоторых случаях символ “^” обозначает начало строки, но в некоторых — отрицание.

// Допустим, мы собрали набор символов, которые нам подходят: “[a-z0-9]” (нас устроит любая маленькая латинская буква или цифра). А теперь предположим, что нас устроит любой символ, кроме этого. Это будет обозначаться вот так: “[^a-z0-9]”.

// Пример:
//
// Текст: “Я люблю кушать суп”
// Надо выбрать все слова.
// RegExp: “[^\s]+”


// список основных метасимволов:
//
// \d — соответствует любой цифре; эквивалент [0-9]
// \D — соответствует любому не числовому символу; эквивалент [^0-9]
// \s — соответствует любому символу whitespace; эквивалент [ \t\n\r\f\v]
// \S — соответствует любому не-whitespace символу; эквивалент [^ \t\n\r\f\v]
// \w — соответствует любой букве или цифре; эквивалент [a-zA-Z0-9_]
// \W — наоборот; эквивалент [^a-zA-Z0-9_]
// . — (просто точка) любой символ, кроме перевода “каретки”

$uri = 'admin/categories/create/1';

foreach ($routes as $key => $val) {
    $pattern = '%^'.$key.'/\d+$%';
    if (preg_match($pattern, $uri, $matches))
      var_dump(
          $matches
      );
}
